<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Raghim AI Widget Test</title>

    <style>

        * {

            margin: 0;

            padding: 0;

            box-sizing: border-box;

        }

        

        body {

            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;

            line-height: 1.6;

            color: #333;

            background: #f5f5f5;

        }

        

        .container {

            max-width: 1200px;

            margin: 0 auto;

            padding: 2rem;

        }

        

        header {

            background: white;

            padding: 2rem;

            margin-bottom: 2rem;

            border-radius: 8px;

            box-shadow: 0 2px 4px rgba(0,0,0,0.1);

        }

        

        h1 {

            color: #2c3e50;

            margin-bottom: 0.5rem;

        }

        

        .content {

            background: white;

            padding: 2rem;

            border-radius: 8px;

            box-shadow: 0 2px 4px rgba(0,0,0,0.1);

            min-height: 400px;

        }

        

        /* Widget container styles */

        #raghim-widget-container {

            position: relative;

        }

        

        /* Raghim AI Widget Styles */

        .rag-widget-modern {

            font-family: Inter, sans-serif;

            font-size: 14px;

            background-color: #ffffff;

            color: #1a202c;

            border-radius: 8px;

            box-shadow: 0 4px 6px rgba(0,0,0,0.1);

            max-width: 350px;

            height: 400px;

            display: flex;

            flex-direction: column;

            overflow: hidden;

            position: fixed;

            bottom: 20px;

            right: 20px;

            z-index: 1000;

        }

        

        .rag-widget-header {

            background-color: #667eea;

            color: white;

            padding: 10px;

            display: flex;

            justify-content: space-between;

            align-items: center;

        }

        

        .rag-widget-header h3 {

            margin: 0;

            font-size: 16px;

        }

        

        .rag-widget-controls button {

            background: none;

            border: none;

            color: white;

            cursor: pointer;

            font-size: 18px;

            margin-left: 5px;

        }

        

        .rag-widget-messages {

            flex: 1;

            overflow-y: auto;

            padding: 10px;

            background-color: #f8f9fa;

        }

        

        .rag-message {

            margin: 10px 0;

            padding: 8px 12px;

            border-radius: 18px;

            max-width: 80%;

            white-space: pre-wrap;

        }

        

        .rag-message.user {

            background-color: #667eea;

            color: white;

            align-self: flex-end;

            margin-left: auto;

        }

        

        .rag-message.assistant {

            background-color: white;

            color: #1a202c;

            border: 1px solid #e0e0e0;

        }

        

        .rag-widget-input {

            display: flex;

            padding: 10px;

            border-top: 1px solid #e0e0e0;

        }

        

        .rag-widget-input input {

            flex: 1;

            padding: 8px 12px;

            border: 1px solid #e0e0e0;

            border-radius: 20px;

            outline: none;

        }

        

        .rag-widget-input button {

            background-color: #667eea;

            color: white;

            border: none;

            padding: 8px 16px;

            border-radius: 20px;

            margin-left: 8px;

            cursor: pointer;

        }

        

        .rag-welcome-message {

            background-color: #e3f2fd;

            padding: 10px;

            border-radius: 8px;

            margin-bottom: 10px;

            white-space: pre-wrap;

        }

        

        .rag-typing-indicator {

            display: none;

            padding: 10px;

            font-style: italic;

            color: #764ba2;

        }

    </style>

</head>

<body>

    <div class="container">

        <header>

            <h1>Raghim AI Widget Test Page</h1>

            <p>Testing embeddable chatbot widget functionality</p>

        </header>

        

        <div class="content">

            <h2>Page Content</h2>

            <p>This is a test page for the Raghim AI embeddable widget.</p>

            <p>The widget should appear in the bottom-right corner of this page.</p>

            <p>You can interact with it to test the chatbot functionality.</p>

        </div>

    </div>

    

    <!-- Raghim AI Chat Widget -->

    <div id="rag-chat-widget" class="rag-widget-modern">

        <div class="rag-widget-header">

            <h3>oraclevpd</h3>

            <div class="rag-widget-controls">

                <button id="minimize-btn">−</button>

                <button id="close-btn">×</button>

            </div>

        </div>

        <div class="rag-widget-messages" id="messages-container">

            <div class="rag-welcome-message">

                <p>Hello! I'm ready to be of service.</p>

            </div>

        </div>

        <div class="rag-widget-input">

            <input type="text" id="message-input" placeholder="Type your message..." />

            <button id="send-btn">Send</button>

        </div>

    </div>

    

    <!-- Raghim AI Widget Script -->

    <script>

        class RAGChatWidget {

            constructor() {

                // Auto-detect HTTPS and use appropriate API URL
                // If page is HTTPS (GitHub Pages), use HTTPS API; otherwise use HTTP
                const isHttps = window.location.protocol === 'https:';
                if (isHttps) {
                    // Use HTTPS API with port 8081 for HTTPS pages (GitHub Pages)
                    this.apiUrl = "https://34.65.50.3:8081/api";
                } else {
                    // Use HTTP API for HTTP pages
                    this.apiUrl = "http://34.65.50.3/api";
                }
                
                this.embedToken = "DQTTXYky0CWsSh-2usxHKk_VMIebuUhwrJxGf7QCyNU";

                this.widgetId = "ab50ca55-5412-439e-a97c-0f98dde0b081";

                this.features = {"show_sources": true, "enable_history": true, "show_typing_indicator": true, "enable_file_upload": false, "show_collection_switcher": false, "enable_feedback": true, "show_timestamps": false, "enable_search": true, "enable_handoff": true};

                this.conversationId = null; // Track conversation ID for history

                this.isSending = false; // Add debouncing flag

                this.lastMessageTime = 0; // Add timestamp tracking

                this.pollingInterval = null; // Track polling interval

                this.lastMessageCount = 0; // Track message count for polling

                

                console.log('Widget initialized with API URL:', this.apiUrl);

                console.log('Widget initialized with embed token:', this.embedToken);

                this.init();

            }

            

            init() {

                this.messageContainer = document.getElementById('messages-container');

                this.messageInput = document.getElementById('message-input');

                this.sendButton = document.getElementById('send-btn');

                this.minimizeButton = document.getElementById('minimize-btn');

                this.closeButton = document.getElementById('close-btn');

                

                this.bindEvents();

            }

            

            bindEvents() {

                this.sendButton.addEventListener('click', () => this.sendMessage());

                this.messageInput.addEventListener('keypress', (e) => {

                    if (e.key === 'Enter') this.sendMessage();

                });

                this.minimizeButton.addEventListener('click', () => this.minimize());

                this.closeButton.addEventListener('click', () => this.close());

            }

            

            async sendMessage() {

                const message = this.messageInput.value.trim();

                if (!message || this.isSending) return;

                

                // Additional debouncing: prevent rapid successive calls

                const now = Date.now();

                if (this.lastMessageTime && (now - this.lastMessageTime) < 1000) {

                    console.log('Message debounced - too soon after last message');

                    return;

                }

                this.lastMessageTime = now;

                

                this.isSending = true;

                this.addMessage(message, 'user');

                this.messageInput.value = '';

                

                // Check if human agent is active - if so, skip API call

                if (this.conversationId) {

                    try {

                        // Use HTTPS API if on HTTPS page for status check
                        const statusApiUrl = window.location.protocol === 'https:' 
                            ? "https://34.65.50.3:8081/api" 
                            : this.apiUrl;
                        
                        const statusResponse = await fetch(`${statusApiUrl}/api/live-chat/widget/conversation/${this.conversationId}/messages`);

                        if (statusResponse.ok) {

                            const statusData = await statusResponse.json();

                            if (statusData.status === 'human_taken') {

                                console.log('Human agent active - skipping API call');

                                this.isSending = false;

                                return;

                            }

                        }

                    } catch (error) {

                        console.log('Could not check conversation status, proceeding with API call');

                    }

                }

                

                if (this.features.show_typing_indicator) {

                    this.showTypingIndicator();

                }

                

                try {

                    console.log('Sending streaming message to:', `${this.apiUrl}/chat/widget/${this.embedToken}`);

                    console.log('Message:', message);

                    

                    // Try streaming endpoint first

                    let response = await this.tryStreamingApiCall(`${this.apiUrl}/chat/widget/${this.embedToken}`, message);

                    

                    // If streaming failed, fall back to HTTPS with correct port

                    if (!response && this.apiUrl.startsWith('http://')) {

                        console.log('Streaming API failed, trying HTTPS fallback...');

                        // Use HTTPS API with port 8081 as fallback

                        const fallbackUrl = "https://34.65.50.3:8081/api";

                        response = await this.tryStreamingApiCall(`${fallbackUrl}/chat/widget/${this.embedToken}`, message);

                    }

                    

                    // If streaming still failed, show error

                    if (!response) {

                        console.log('Streaming failed');

                        this.addMessage('Sorry, I encountered an error. Please try again.', 'assistant');

                    }

                } catch (error) {

                    console.error('Network Error:', error);

                    this.addMessage('Sorry, I encountered an error. Please try again.', 'assistant');

                } finally {

                    this.isSending = false;

                    if (this.features.show_typing_indicator) {

                        this.hideTypingIndicator();

                    }

                }

            }

            

            async tryStreamingApiCall(url, message) {

                try {

                    const response = await fetch(url, {

                        method: 'POST',

                        headers: {

                            'Content-Type': 'application/json',

                        },

                        body: JSON.stringify({ 

                            message: message,

                            conversation_id: this.conversationId

                        })

                    });

                    

                    if (response.ok) {

                        console.log('Streaming response started');

                        await this.processStreamingResponse(response);

                        return response;

                    } else {

                        console.log('Streaming response not ok:', response.status);

                        return null;

                    }

                } catch (error) {

                    console.log('Streaming API call failed:', error.message);

                    return null;

                }

            }

            

            async processStreamingResponse(response) {

                const reader = response.body.getReader();

                const decoder = new TextDecoder();

                let buffer = '';

                let fullResponse = '';

                let sources = [];

                let conversationId = null;

                

                // Create a placeholder message for streaming

                const messageId = 'streaming-' + Date.now();

                this.addStreamingMessage('', 'assistant', messageId);

                

                try {

                    while (true) {

                        const { done, value } = await reader.read();

                        if (done) break;

                        

                        const text = decoder.decode(value, { stream: true });

                        buffer += text;

                        

                        // Split by lines and process complete lines

                        const lines = buffer.split('\n');

                        buffer = lines.pop() || '';

                        

                        for (const line of lines) {

                            if (line.startsWith('data: ')) {

                                const content = line.slice(6).trim();

                                

                                if (content === '[DONE]') {

                                    console.log('Streaming completed');

                                    break;

                                }

                                

                                if (content) {

                                    try {

                                        const data = JSON.parse(content);

                                        

                                        switch (data.type) {

                                            case 'chunk':

                                                if (data.content) {

                                                    fullResponse += data.content;

                                                    this.updateStreamingMessage(messageId, fullResponse);

                                                }

                                                break;

                                            

                                            case 'sources':

                                                if (data.sources && Array.isArray(data.sources)) {

                                                    sources = data.sources;

                                                }

                                                break;

                                            

                                            case 'complete':

                                                if (data.stats && data.stats.conversation_id) {

                                                    conversationId = data.stats.conversation_id;

                                                    this.conversationId = conversationId;

                                                    console.log('Updated conversation ID from stream:', this.conversationId);

                                                    this.startMessagePolling();

                                                }

                                                break;

                                            

                                            case 'human_agent_active':

                                                this.addMessage(data.message, 'assistant');

                                                break;

                                            

                                            case 'error':

                                                this.addMessage('Error: ' + data.error, 'assistant');

                                                break;

                                        }

                                    } catch (parseError) {

                                        console.error('JSON Parse Error:', parseError);

                                    }

                                }

                            }

                        }

                    }

                } finally {

                    reader.releaseLock();

                    

                    // Finalize the streaming message

                    if (fullResponse.trim()) {

                        this.finalizeStreamingMessage(messageId, fullResponse, sources);

                    } else {

                        this.removeStreamingMessage(messageId);

                    }

                }

            }

            

            addStreamingMessage(content, role, messageId) {

                const messageDiv = document.createElement('div');

                messageDiv.className = `rag-message ${role}`;

                messageDiv.id = messageId;

                messageDiv.textContent = content;

                

                if (role === 'user') {

                    messageDiv.style.cssText += `

                        background-color: #007bff;

                        color: white;

                        margin-left: auto;

                        white-space: pre-wrap;

                    `;

                } else {

                    messageDiv.style.cssText += `

                        background-color: white;

                        color: #333;

                        border: 1px solid #e0e0e0;

                        white-space: pre-wrap;

                    `;

                }

                

                this.messageContainer.appendChild(messageDiv);

                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;

            }

            

            updateStreamingMessage(messageId, content) {

                const messageDiv = document.getElementById(messageId);

                if (messageDiv) {

                    messageDiv.textContent = content;

                    this.messageContainer.scrollTop = this.messageContainer.scrollHeight;

                }

            }

            

            finalizeStreamingMessage(messageId, content, sources) {

                const messageDiv = document.getElementById(messageId);

                if (messageDiv) {

                    messageDiv.textContent = content;

                    

                    // Add sources if available

                    if (sources && this.features.show_sources && sources.length > 0) {

                        const sourcesDiv = document.createElement('div');

                        sourcesDiv.className = 'rag-sources';

                        sourcesDiv.innerHTML = '<small>Sources: ' + sources.map(s => s.metadata.source || 'Unknown').join(', ') + '</small>';

                        messageDiv.appendChild(sourcesDiv);

                    }

                    

                    this.messageContainer.scrollTop = this.messageContainer.scrollHeight;

                }

            }

            

            removeStreamingMessage(messageId) {

                const messageDiv = document.getElementById(messageId);

                if (messageDiv) {

                    messageDiv.remove();

                }

            }

            

            async tryApiCall(url, message) {

                try {

                    const response = await fetch(url, {

                        method: 'POST',

                        headers: {

                            'Content-Type': 'application/json',

                        },

                        body: JSON.stringify({ 

                            message: message,

                            conversation_id: this.conversationId

                        })

                    });

                    return response;

                } catch (error) {

                    console.log('API call failed:', error.message);

                    return null;

                }

            }

            

            addMessage(content, role, sources = null) {

                const messageDiv = document.createElement('div');

                messageDiv.className = `rag-message ${role}`;

                messageDiv.textContent = content;

                

                if (sources && this.features.show_sources && sources.length > 0) {

                    const sourcesDiv = document.createElement('div');

                    sourcesDiv.className = 'rag-sources';

                    sourcesDiv.innerHTML = '<small>Sources: ' + sources.map(s => s.metadata.source || 'Unknown').join(', ') + '</small>';

                    messageDiv.appendChild(sourcesDiv);

                }

                

                this.messageContainer.appendChild(messageDiv);

                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;

            }

            

            showTypingIndicator() {

                const indicator = document.createElement('div');

                indicator.className = 'rag-typing-indicator';

                indicator.id = 'typing-indicator';

                indicator.textContent = 'Assistant is typing...';

                this.messageContainer.appendChild(indicator);

                indicator.style.display = 'block';

            }

            

            hideTypingIndicator() {

                const indicator = document.getElementById('typing-indicator');

                if (indicator) {

                    indicator.remove();

                }

            }

            

            minimize() {

                document.getElementById('rag-chat-widget').style.display = 'none';

            }

            

            close() {

                // Stop polling before closing

                this.stopMessagePolling();

                document.getElementById('rag-chat-widget').remove();

            }

            

            startMessagePolling() {

                if (this.pollingInterval || !this.conversationId) return;

                

                console.log('Starting message polling for conversation:', this.conversationId);

                this.pollingInterval = setInterval(() => {

                    this.fetchAgentMessages();

                }, 3000); // Poll every 3 seconds

            }

            

            stopMessagePolling() {

                if (this.pollingInterval) {

                    clearInterval(this.pollingInterval);

                    this.pollingInterval = null;

                    console.log('Stopped message polling');

                }

            }

            

            async fetchAgentMessages() {

                if (!this.conversationId) return;

                

                try {

                    // Use HTTPS API if on HTTPS page for polling
                    const pollingApiUrl = window.location.protocol === 'https:' 
                        ? "https://34.65.50.3:8081/api" 
                        : this.apiUrl;

                    const response = await fetch(`${pollingApiUrl}/api/live-chat/widget/conversation/${this.conversationId}/messages`, {

                        method: 'GET',

                        headers: {

                            'Content-Type': 'application/json',

                        }

                    });

                    

                    if (response.ok) {

                        const data = await response.json();

                        if (data?.messages && Array.isArray(data.messages)) {

                            // Only update if we have new messages

                            if (data.messages.length > this.lastMessageCount) {

                                this.updateMessagesFromServer(data.messages);

                                this.lastMessageCount = data.messages.length;

                            }

                        }

                    }

                } catch (error) {

                    console.error('Error fetching agent messages:', error);

                }

            }

            

            updateMessagesFromServer(messages) {

                // Clear existing messages and rebuild from server

                this.messageContainer.innerHTML = '';

                

                messages.forEach(msg => {

                    const role = msg.role === 'user' ? 'user' : msg.role === 'assistant' ? 'assistant' : 'agent';

                    this.addMessage(msg.content, role);

                });

                

                // Scroll to bottom

                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;

            }

        }

        

        // Initialize widget

        new RAGChatWidget();

    </script>

</body>

</html>

